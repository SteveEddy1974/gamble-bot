"""Lightweight metrics counters and HTTP exporter used for canary monitoring.

- Provides simple counter increment/get methods.
- Optional threaded HTTP server exposing metrics in plain 'key value' format at /metrics.
"""
from threading import Thread
from http.server import HTTPServer, BaseHTTPRequestHandler
from typing import Dict
import time

_counters: Dict[str, int] = {}


def inc(name: str, amt: int = 1) -> None:
    _counters[name] = _counters.get(name, 0) + amt


def get_counters() -> Dict[str, int]:
    return dict(_counters)


class _MetricsHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path != '/metrics':
            self.send_response(404)
            self.end_headers()
            return
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain; version=0.0.4')
        self.end_headers()
        text = get_metrics_text()
        self.wfile.write(text.encode('utf-8'))


class MetricsServer:
    def __init__(self, host: str = '0.0.0.0', port: int = 8000):
        self.host = host
        self.port = port
        self._server = HTTPServer((self.host, self.port), _MetricsHandler)
        self._thread = Thread(target=self._server.serve_forever, daemon=True)

    def start(self) -> None:
        self._thread.start()

    def stop(self) -> None:
        try:
            self._server.shutdown()
            self._server.server_close()
        except Exception:
            pass


# Helper: produce Prometheus-friendly exposition text

def _sanitize_metric_name(name: str) -> str:
    # Replace non-alphanumeric with underscore and collapse repeated underscores
    import re
    s = re.sub(r"[^0-9A-Za-z]", "_", name)
    s = re.sub(r"_+", "_", s).strip('_')
    return s or 'metric'


def get_metrics_text() -> str:
    """Return metrics in simple Prometheus exposition format.

    Each counter is emitted as:
      # HELP <name> autogenerated
      # TYPE <name> counter
      <name> <value>
    """
    out_lines = []
    for k in sorted(_counters.keys()):
        name = _sanitize_metric_name(k)
        out_lines.append(f"# HELP {name} autogenerated")
        out_lines.append(f"# TYPE {name} counter")
        out_lines.append(f"{name} {_counters[k]}")
    return "\n".join(out_lines) + "\n"


# Optional Prometheus client integration
_has_prometheus = False
_prom_counters = {}
_prom_rpc_counter = None
_prom_server = None
_prom_server_thread = None
try:
    from prometheus_client import Counter, Gauge, generate_latest
    from prometheus_client import exposition
    from wsgiref.simple_server import make_server
    from prometheus_client import make_wsgi_app
    import socket
    _has_prometheus = True
    # Define core counters
    _prom_counters['bets_placed'] = Counter('bets_placed', 'Number of bets placed')
    _prom_counters['bets_accepted'] = Counter('bets_accepted', 'Number of bets accepted')
    _prom_counters['settlements_processed'] = Counter('settlements_processed', 'Number of settlements processed')
    _prom_counters['settlement_wins'] = Counter('settlement_wins', 'Number of settlement wins')
    _prom_counters['settlement_losses'] = Counter('settlement_losses', 'Number of settlement losses')
    _prom_counters['exchange_rpc_retries'] = Counter('exchange_rpc_retries', 'Number of exchange rpc retries')
    _prom_counters['exchange_rpc_errors'] = Counter('exchange_rpc_errors', 'Number of exchange rpc errors')
    # RPC counter with method label
    _prom_rpc_counter = Counter('exchange_rpc_retries_by_method', 'RPC retries partitioned by method', ['method'])
except Exception:
    _has_prometheus = False


def start_prometheus_server(port: int | None = None, host: str = '127.0.0.1') -> int:
    """Start a local WSGI server exposing Prometheus metrics. If port is None, an ephemeral port is chosen and returned."""
    global _prom_server, _prom_server_thread
    if not _has_prometheus:
        raise RuntimeError('prometheus_client not available')
    app = make_wsgi_app()
    # Bind to ephemeral port if port is None
    server = make_server(host, 0 if port is None else port, app)
    port_used = server.server_address[1]
    from threading import Thread
    t = Thread(target=server.serve_forever, daemon=True)
    t.start()
    _prom_server = server
    _prom_server_thread = t
    return port_used


def stop_prometheus_server() -> None:
    global _prom_server, _prom_server_thread
    if _prom_server:
        try:
            _prom_server.shutdown()
            _prom_server.server_close()
        except Exception:
            pass
        _prom_server = None
        _prom_server_thread = None

# Convenience: incrementers for common events

def inc_bet_placed():
    inc('bets_placed')
    if _has_prometheus:
        try:
            _prom_counters['bets_placed'].inc()
        except Exception:
            pass


def inc_bet_accepted():
    inc('bets_accepted')
    if _has_prometheus:
        try:
            _prom_counters['bets_accepted'].inc()
        except Exception:
            pass


def inc_settlement_processed():
    inc('settlements_processed')
    if _has_prometheus:
        try:
            _prom_counters['settlements_processed'].inc()
        except Exception:
            pass


def inc_settlement_win():
    inc('settlement_wins')
    if _has_prometheus:
        try:
            _prom_counters['settlement_wins'].inc()
        except Exception:
            pass


def inc_settlement_loss():
    inc('settlement_losses')
    if _has_prometheus:
        try:
            _prom_counters['settlement_losses'].inc()
        except Exception:
            pass


def inc_exchange_rpc_retry(method: str | None = None):
    """Increment generic RPC retry counter, and a method-specific counter when provided."""
    inc('exchange_rpc_retries')
    if method:
        # sanitize and attach
        name = f"exchange_rpc_retries_{_sanitize_metric_name(method)}"
        inc(name)
    if _has_prometheus:
        try:
            _prom_counters['exchange_rpc_retries'].inc()
            if method and _prom_rpc_counter is not None:
                _prom_rpc_counter.labels(method=method).inc()
        except Exception:
            pass


def inc_exchange_rpc_error(method: str | None = None):
    """Increment generic RPC error counter, and a method-specific counter when provided."""
    inc('exchange_rpc_errors')
    if method:
        name = f"exchange_rpc_errors_{_sanitize_metric_name(method)}"
        inc(name)
    if _has_prometheus:
        try:
            _prom_counters['exchange_rpc_errors'].inc()
            # method specific errors use a labeled counter too
            if method:
                # reuse rpc counter name for errors using labels
                if _prom_rpc_counter is not None:
                    _prom_rpc_counter.labels(method=method).inc()
        except Exception:
            pass
